#!/usr/bin/env python3
import os
import argparse
import subprocess
import numpy as np

class Timestimer:
	def __init__(self):
		self._start = os.times()

	def elapsed(self):
		current = list(os.times())
		start = list(self._start)
		for i in range(5):
			current[i] = round(current[i]-start[i], 2)
		return tuple(current)

def measure_once(call):
	timer = Timestimer()
	sp=subprocess.Popen(call, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
	sp.wait()
	_,_,usr,sys,_ = timer.elapsed()
	#print(usr, sys)
	return usr,sys

def measure_parallel(call, n):
	sps=[subprocess.Popen(call, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE) for _ in range(n)]
	usertimes = []
	for sp in sps:
		sp.wait()
		usertimes.append(float(sp.stderr.readlines()[-1]))
	return usertimes

if __name__=='__main__':
	parser = argparse.ArgumentParser(description='Measure the program execution time.')
	parser.add_argument('-n', type=int, default=3, help='number of times to measure.')
	parser.add_argument('-p', action='store_true', help='do measurements in parallel')
	parser.add_argument('command', nargs=argparse.REMAINDER)
	args = parser.parse_args()
	#print(args)

	call = args.command
	#print('Call:', call)

	print('Start measuring..')
	utimes = []
	if args.p:
		utimes = measure_parallel(['/usr/bin/time', '-f%U']+call, args.n)
		for utime in utimes:
			print(' - measured:', utime)
	else:
		for _ in range(args.n):
			try:
				utime,stime = measure_once(call)
			except KeyboardInterrupt:
				print('Measurement interrupted.')
				break
			print(' - measured:', utime)
			utimes.append(utime)

	if len(utimes) == 0:
		print('No measurements, no math!')
	elif len(utimes) == 1:
		print('Measured once:', utimes[0])
	else:
		print('Measured {0} times.'.format(len(utimes)))
		mean = np.mean(utimes)
		stdev = np.std(utimes)
		print('Mean utime: {:7.2f}'.format(mean))
		print('Std. dev:   {:7.2f} ({:7.2%})'.format(stdev, stdev/mean if mean!=0.0 else float('nan')))
		print('Min, max:   {:7.2f}, {:7.2f}'.format(min(utimes), max(utimes)))



